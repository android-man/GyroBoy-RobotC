#pragma config(Sensor, S2,     Sgiro,           sensorEV3_Gyro)
#pragma config(Motor,  motorA,          LMotor,        tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          RMotor,        tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float gn_dth_dt,gn_th,gn_y,gn_dy_dt,kp,ki,kd,gear_down_ratio,dt;

const float your_wheel_diameter = 54;
int steering = 0;
int acceleration = 50;
int speed = 25;

task main()
{
  gear_down_ratio = 1;

  dt = 0.010;

  // Customize PID constants. These variables are global, so you can optionally dynamically change them in your main task.
  gn_dth_dt = 0.23;
  gn_th = 25.00;
  gn_y = 272.8;
  gn_dy_dt = 24.6;
  kp = 0.0336;
  ki = 0.2688;
  kd = 0.000504;

  ///////////////////////////
  //END ADVANCED USER CONTROL
  ///////////////////////////


  //MATH CONSTANTS
  const float radius = your_wheel_diameter/1000;
  const float degtorad = PI/180;

  //SETUP VARIABLES FOR CALCULATIONS
  float u = 0;                    // Sensor Measurement (raw)
  float th = 0,//Theta            // Angle of robot (degree)
        dth_dt = 0;//dTheta/dt    // Angular velocity of robot (degree/sec)
  float e = 0,//Error             // Sum of four states to be kept zero: th, dth_dt, y, dy_dt.
        de_dt = 0,//dError/dt     // Change of above error
        _edt = 0,//Integral Error // Accumulated error in time
        e_prev = 0;//Previous Error/ Error found in previous loop cycle
  float pid = 0;                  // SUM OF PID CALCULATION
  float y = 0,//y                     // Measured Motor position (degrees)
        dy_dt = 0,//dy/dt             // Measured motor velocity (degrees/sec)
	      v = 0,//velocity          // Desired motor velocity (degrees/sec)
	      y_ref = 0;//reference pos // Desired motor position (degrees)
  int motorpower = 0,             // Power ultimately applied to motors
      last_steering = 0,          // Steering value in previous cycle
      straight = 0,               // Average motor position for synchronizing
      d_pwr = 0;                  // Change in power required for synchronizing
  const int n_max = 20;            // Number of measurement used for floating motor speed average
  int n = 0,n_comp = 0,           // Intermediate variables needed to compute measured motor speed
  encoder[n_max];                 // Array containing last n_max motor positions
  memset(&encoder[0],0,sizeof(encoder));
//  starting_balancing_task = false;// We're done configuring. Main task now resumes.


  clearTimer(T4);                 // This timer is used in the driver. Do not use it for other purposes!
	resetGyro(Sgiro);
  while(true)
  {

    //READ GYRO SENSOR
		th=getGyroDegrees(Sgiro);

    //ADJUST REFERENCE POSITION ON SPEED AND ACCELERATION
    if(v < speed*10){
    v = v + acceleration*10*dt;}
    else if(v > speed*10){
    v = v - acceleration*10*dt;}
    y_ref = y_ref + v*dt;

  	//COMPUTE MOTOR ENCODER POSITION AND SPEED
  	n++;if(n == n_max){n = 0;}
  	encoder[n] = nMotorEncoder[LMotor] + nMotorEncoder[RMotor] + y_ref;
  	n_comp = n+1;if(n_comp == n_max){n_comp = 0;}
  	y = encoder[n]*degtorad*radius/gear_down_ratio;
  	dy_dt = (encoder[n] - encoder[n_comp])/(dt*(n_max-1))*degtorad*radius/gear_down_ratio;

  	//COMPUTE COMBINED ERROR AND PID VALUES
  	e = gn_th * th + gn_dth_dt * dth_dt + gn_y * y + gn_dy_dt * dy_dt;
  	de_dt = (e - e_prev)/dt;
  	_edt = _edt + e*dt;
  	e_prev = e;
  	pid = (kp*e + ki*_edt + kd*de_dt)/radius*gear_down_ratio;

  	//ADJUST MOTOR SPEED TO STEERING AND SYNCHING
    if(steering == 0){
        if(last_steering != 0){
	        straight = nMotorEncoder[RMotor] - nMotorEncoder[LMotor];}
		    d_pwr = (nMotorEncoder[RMotor] - nMotorEncoder[LMotor] - straight)/(radius*10/gear_down_ratio);}
    else{d_pwr = steering/(radius*10/gear_down_ratio);}
    last_steering = steering;

  	//CONTROL MOTOR POWER AND STEERING
  	motorpower = 	pid;
    motor[LMotor] = motorpower + d_pwr;
    motor[RMotor] = motorpower - d_pwr;

    //ERROR CHECKING OR SHUTDOWN
    if(abs(th)>90 || abs(motorpower) > 2000){
      stopAllTasks();}

    //WAIT THEN REPEAT
  	while(time1[T4] < dt*1000){
  	  wait1Msec(1);}
  	clearTimer(T4);
  }
}
